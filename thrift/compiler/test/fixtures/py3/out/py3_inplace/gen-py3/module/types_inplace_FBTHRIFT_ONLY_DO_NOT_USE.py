#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/py3/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib

import thrift.py3.types
import module.thrift_enums as _fbthrift_python_enums



def get_types_reflection():
    return importlib.import_module(
        "module.types_reflection"
    )

_fbthrift__module_name__ = "module.types"

__all__ = []

### Enums ###

class AnEnum(thrift.py3.types.CompiledEnum, int):
    NOTSET = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_AnEnum()

    @staticmethod
    def __get_thrift_name__():
        return "module.AnEnum"

    def _to_python(self):
        return _fbthrift_python_enums.AnEnum(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("AnEnum")


class AnEnumRenamed(thrift.py3.types.CompiledEnum, int):
    name_ = 0
    value_ = 1
    renamed_ = 2

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_AnEnumRenamed()

    @staticmethod
    def __get_thrift_name__():
        return "module.AnEnumRenamed"

    def _to_python(self):
        return _fbthrift_python_enums.AnEnumRenamed(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("AnEnumRenamed")


class Flags(thrift.py3.types.Flag):
    flag_A = 1
    flag_B = 2
    flag_C = 4
    flag_D = 8

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_Flags()

    @staticmethod
    def __get_thrift_name__():
        return "module.Flags"

    def _to_python(self):
        return _fbthrift_python_enums.Flags(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("Flags")


### Union Enums ###

class __BinaryUnionType(enum.Enum):
    iobuf_val = 1
    EMPTY = 0

    __module__ = _fbthrift__module_name__
    __slots__ = ()
__all__.append("__BinaryUnionType")


### Containers ###
class List__i16(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i16):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i16._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i16)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i16()


Sequence.register(List__i16)


__all__.append("List__i16")

class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()


Sequence.register(List__i32)


__all__.append("List__i32")

class List__i64(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i64):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i64._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i64()


Sequence.register(List__i64)


__all__.append("List__i64")

class List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            check_method = List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__string()


Sequence.register(List__string)


__all__.append("List__string")

class List__SimpleStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__SimpleStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__SimpleStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__SimpleStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, SimpleStruct)
        ):
            raise TypeError(f"{item!r} is not of type SimpleStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, SimpleStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__SimpleStruct()


Sequence.register(List__SimpleStruct)


__all__.append("List__SimpleStruct")

class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()


Set.register(Set__i32)


__all__.append("Set__i32")

class Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__string()


Set.register(Set__string)


__all__.append("Set__string")

class Map__string_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_string._check_key_type_or_raise
            check_val = Map__string_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_string()


Mapping.register(Map__string_string)

__all__.append("Map__string_string")

class Map__string_SimpleStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_SimpleStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_SimpleStruct._check_key_type_or_raise
            check_val = Map__string_SimpleStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_SimpleStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, SimpleStruct)
        ):
            raise TypeError(f"{item!r} is not of type SimpleStruct")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_SimpleStruct()


Mapping.register(Map__string_SimpleStruct)

__all__.append("Map__string_SimpleStruct")

class Map__string_i16(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i16):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i16._check_key_type_or_raise
            check_val = Map__string_i16._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i16)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i16()


Mapping.register(Map__string_i16)

__all__.append("Map__string_i16")

class List__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[int]")
        if not isinstance(item, List__i32):
            item = List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, List__i32):
            return item
        try:
            return List__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__i32()


Sequence.register(List__List__i32)


__all__.append("List__List__i32")

class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()


Mapping.register(Map__string_i32)

__all__.append("Map__string_i32")

class Map__string_Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_Map__string_i32._check_key_type_or_raise
            check_val = Map__string_Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, int]")
        if not isinstance(item, Map__string_i32):
            item = Map__string_i32(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_i32)

__all__.append("Map__string_Map__string_i32")

class List__Set__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[str]")
        if not isinstance(item, Set__string):
            item = Set__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Set__string):
            return item
        try:
            return Set__string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__string()


Sequence.register(List__Set__string)


__all__.append("List__Set__string")

class Map__string_List__SimpleStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_List__SimpleStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_List__SimpleStruct._check_key_type_or_raise
            check_val = Map__string_List__SimpleStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_List__SimpleStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[SimpleStruct]")
        if not isinstance(item, List__SimpleStruct):
            item = List__SimpleStruct(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_List__SimpleStruct()


Mapping.register(Map__string_List__SimpleStruct)

__all__.append("Map__string_List__SimpleStruct")

class List__List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[str]")
        if not isinstance(item, List__string):
            item = List__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, List__string):
            return item
        try:
            return List__string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__string()


Sequence.register(List__List__string)


__all__.append("List__List__string")

class List__Set__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[int]")
        if not isinstance(item, Set__i32):
            item = Set__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Set__i32):
            return item
        try:
            return Set__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)


__all__.append("List__Set__i32")

class List__Map__string_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__string_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__string_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__string_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, str]")
        if not isinstance(item, Map__string_string):
            item = Map__string_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Map__string_string):
            return item
        try:
            return Map__string_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__string_string()


Sequence.register(List__Map__string_string)


__all__.append("List__Map__string_string")

class List__binary(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__binary):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[bytes] field, explicitly convert it first.")
            check_method = List__binary._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__binary)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bytes)
        ):
            raise TypeError(f"{item!r} is not of type bytes")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bytes):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__binary()


Sequence.register(List__binary)


__all__.append("List__binary")

class Set__binary(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__binary):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[bytes] field, explicitly convert it first.")
            check_method = Set__binary._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__binary)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bytes)
        ):
            raise TypeError(f"{item!r} is not of type bytes")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bytes):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__binary()


Set.register(Set__binary)


__all__.append("Set__binary")

class List__AnEnum(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__AnEnum):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__AnEnum._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__AnEnum)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, AnEnum) or
            isinstance(item, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{item!r} is not of type AnEnum")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, AnEnum):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__AnEnum()


Sequence.register(List__AnEnum)


__all__.append("List__AnEnum")

class _std_unordered_map__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _std_unordered_map__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _std_unordered_map__Map__i32_i32._check_key_type_or_raise
            check_val = _std_unordered_map__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _std_unordered_map__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___std_unordered_map__Map__i32_i32()


Mapping.register(_std_unordered_map__Map__i32_i32)

__all__.append("_std_unordered_map__Map__i32_i32")

class _MyType__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _MyType__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _MyType__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__List__i32()


Sequence.register(_MyType__List__i32)


__all__.append("_MyType__List__i32")

class _MyType__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = _MyType__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, _MyType__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__Set__i32()


Set.register(_MyType__Set__i32)


__all__.append("_MyType__Set__i32")

class _MyType__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _MyType__Map__i32_i32._check_key_type_or_raise
            check_val = _MyType__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _MyType__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__Map__i32_i32()


Mapping.register(_MyType__Map__i32_i32)

__all__.append("_MyType__Map__i32_i32")

class _py3_simple_AdaptedList__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedList__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _py3_simple_AdaptedList__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _py3_simple_AdaptedList__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedList__List__i32()


Sequence.register(_py3_simple_AdaptedList__List__i32)


__all__.append("_py3_simple_AdaptedList__List__i32")

class _py3_simple_AdaptedSet__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedSet__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = _py3_simple_AdaptedSet__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, _py3_simple_AdaptedSet__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedSet__Set__i32()


Set.register(_py3_simple_AdaptedSet__Set__i32)


__all__.append("_py3_simple_AdaptedSet__Set__i32")

class _py3_simple_AdaptedMap__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedMap__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _py3_simple_AdaptedMap__Map__i32_i32._check_key_type_or_raise
            check_val = _py3_simple_AdaptedMap__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _py3_simple_AdaptedMap__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedMap__Map__i32_i32()


Mapping.register(_py3_simple_AdaptedMap__Map__i32_i32)

__all__.append("_py3_simple_AdaptedMap__Map__i32_i32")

class Map__i32_double(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_double):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_double._check_key_type_or_raise
            check_val = Map__i32_double._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_double)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, (float, int))
        ):
            raise TypeError(f"{item!r} is not of type float")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_double()


Mapping.register(Map__i32_double)

__all__.append("Map__i32_double")

class List__Map__i32_double(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__i32_double):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__i32_double._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__i32_double)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, float]")
        if not isinstance(item, Map__i32_double):
            item = Map__i32_double(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Map__i32_double):
            return item
        try:
            return Map__i32_double(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__i32_double()


Sequence.register(List__Map__i32_double)


__all__.append("List__Map__i32_double")

class Map__AnEnumRenamed_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__AnEnumRenamed_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__AnEnumRenamed_i32._check_key_type_or_raise
            check_val = Map__AnEnumRenamed_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__AnEnumRenamed_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, AnEnumRenamed) or
            isinstance(key, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{key!r} is not of type AnEnumRenamed")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, AnEnumRenamed):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__AnEnumRenamed_i32()


Mapping.register(Map__AnEnumRenamed_i32)

__all__.append("Map__AnEnumRenamed_i32")


### Structured Types ###
class SimpleException:
    __module__ = _fbthrift__module_name__


__all__.append("SimpleException")

class OptionalRefStruct:
    __module__ = _fbthrift__module_name__


__all__.append("OptionalRefStruct")

class SimpleStruct:
    __module__ = _fbthrift__module_name__


__all__.append("SimpleStruct")

class HiddenTypeFieldsStruct:
    __module__ = _fbthrift__module_name__


__all__.append("HiddenTypeFieldsStruct")

class ComplexStruct:
    __module__ = _fbthrift__module_name__


__all__.append("ComplexStruct")

class BinaryUnion:
    __module__ = _fbthrift__module_name__


__all__.append("BinaryUnion")

class BinaryUnionStruct:
    __module__ = _fbthrift__module_name__


__all__.append("BinaryUnionStruct")

class CustomFields:
    __module__ = _fbthrift__module_name__


__all__.append("CustomFields")

class CustomTypedefFields:
    __module__ = _fbthrift__module_name__


__all__.append("CustomTypedefFields")

class AdaptedTypedefFields:
    __module__ = _fbthrift__module_name__


__all__.append("AdaptedTypedefFields")


### Constants
A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = "Good word"
SOME_BYTES = b"bytes"
A_STRUCT = SimpleStruct(is_on=True, tiny_int=5, small_int=6, nice_sized_int=7, big_int=8, real=9.9)
EMPTY = SimpleStruct()
WORD_LIST = List__string(("the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog", ))
SOME_MAP = List__Map__i32_double((Map__i32_double( { 1: 1.1, 2: 2.2 }), Map__i32_double( { 3: 3.3 }), ))
DIGITS = Set__i32((1, 2, 3, 4, 5, ))
A_CONST_MAP = Map__string_SimpleStruct( { "simple": SimpleStruct(is_on=False, tiny_int=50, small_int=61, nice_sized_int=72, big_int=83, real=99.9) })
ANOTHER_CONST_MAP = Map__AnEnumRenamed_i32( { AnEnumRenamed.name_: 0, AnEnumRenamed.value_: 1, AnEnumRenamed.renamed_: 2 })
